/**
 * ArxivExtractor - Specialized extractor for arXiv HTML papers
 * 
 * ArXiv HTML has a very well-organized structure generated by LaTeXML:
 * - Authors: <span class="ltx_creator ltx_role_author">
 * - Sections: <section class="ltx_section" id="S1">, <section class="ltx_section" id="S2">, etc.
 * - References: <section class="ltx_bibliography" id="bib">
 * - Abstract: <div class="ltx_abstract" id="abstract">
 * - Title: <h1 class="ltx_title ltx_title_document">
 * - Figures: <figure class="ltx_figure">
 * 
 * This extractor:
 * 1. Extracts arXiv-specific structured data (including References!)
 * 2. Converts directly to standardized PageContent format for AI Services
 * 3. Preserves hierarchical section structure using ContentSection
 */

import { PageContent, ContentSection, Reference, Figure } from '../types';

/**
 * Extract arXiv paper and convert to standardized PageContent
 * This is the main entry point for the arXiv extractor
 */
export function extractArxivPaper(doc: Document): PageContent | null {
    if (!isArxivHtml(doc)) {
        return null;
    }

    const title = extractTitle(doc);
    const authors = extractAuthors(doc);
    const abstract = extractAbstract(doc);
    const sections = extractSections(doc);
    const arxivMetadata = extractMetadata(doc);
    const references = extractReferences(doc);
    const figures = extractFigures(doc);

    // Generate markdown content from sections
    const mainContent = sectionsToMarkdown(sections);

    // Extract tags from section titles
    const tags = extractTags(sections);

    // Analyze abstract for paper structure
    const paperStructure = analyzePaperStructure(abstract, sections);

    return {
        title,
        url: window.location.href,
        abstract,
        mainContent,
        fullText: abstract + '\n\n' + mainContent,

        metadata: {
            authors,
            contentType: 'research-paper',
            tags,
            description: abstract,
            sections,
            paperStructure,
            references,
            figures,
            publishDate: arxivMetadata.publishDate,
            arxivVersion: arxivMetadata.version,
            subjects: arxivMetadata.subjects,
            extra: {
                arxivId: arxivMetadata.arxivId,
                license: arxivMetadata.license,
            }
        },

        images: figures.map(f => f.imageUrl).filter((url): url is string => Boolean(url)),
        links: [],

        extractorType: 'arxiv'
    };
}

/**
 * Convert sections to markdown format
 */
function sectionsToMarkdown(sections: ContentSection[]): string {
    const parts: string[] = [];

    sections.forEach(section => {
        parts.push(...sectionToMarkdown(section, 2)); // Start at h2 (h1 is for title)
    });

    return parts.join('\n');
}

/**
 * Convert a single section to markdown
 */
function sectionToMarkdown(section: ContentSection, baseLevel: number): string[] {
    const parts: string[] = [];
    const prefix = '#'.repeat(baseLevel);

    // Section heading
    const heading = section.number
        ? `${prefix} ${section.number} ${section.title}`
        : `${prefix} ${section.title}`;
    parts.push(heading);

    // Section content
    if (section.content) {
        parts.push(section.content);
        parts.push('');
    }

    // Subsections
    section.subsections?.forEach(subsection => {
        parts.push(...sectionToMarkdown(subsection, baseLevel + 1));
    });

    return parts;
}

/**
 * Extract tags from section titles
 */
function extractTags(sections: ContentSection[]): string[] {
    const tags: string[] = [];

    sections.forEach(section => {
        // Skip generic sections
        if (!['Introduction', 'Conclusion', 'References'].includes(section.title)) {
            tags.push(section.title);
        }
    });

    return tags
}

/**
 * Analyze paper structure from abstract and sections
 */
function analyzePaperStructure(abstract: string, sections: ContentSection[]): PageContent['metadata']['paperStructure'] {
    const abstractLower = abstract.toLowerCase();

    // Try to identify research question
    const researchQuestion = abstractLower.includes('question') || abstractLower.includes('problem')
        ? abstract.split('.')[0] + '.'
        : undefined;

    // Main contribution is typically in the abstract
    const mainContribution = abstract;

    // Find methodology section
    const methodSection = sections.find((s: ContentSection) =>
        s.title.toLowerCase().includes('method') ||
        s.title.toLowerCase().includes('approach') ||
        s.title.toLowerCase().includes('framework')
    );
    const methodology = methodSection?.content;

    // Find results/conclusion
    const resultsSection = sections.find((s: ContentSection) =>
        s.title.toLowerCase().includes('result') ||
        s.title.toLowerCase().includes('conclusion') ||
        s.title.toLowerCase().includes('finding')
    );
    const keyFindings = resultsSection?.content;

    return {
        researchQuestion,
        mainContribution,
        methodology,
        keyFindings
    };
}

/**
 * Extract title from arXiv HTML
 */
function extractTitle(doc: Document): string {
    const titleElement = doc.querySelector('h1.ltx_title.ltx_title_document');
    return titleElement?.textContent?.trim() || 'Untitled';
}

/**
 * Extract authors from arXiv HTML
 * Pattern: <span class="ltx_creator ltx_role_author">
 */
function extractAuthors(doc: Document): string[] {
    const authors: string[] = [];
    const authorElements = doc.querySelectorAll('span.ltx_creator.ltx_role_author');

    authorElements.forEach(element => {
        // Get the personname element
        const personnameElement = element.querySelector('span.ltx_personname');
        if (personnameElement) {
            // Extract just the name (first line before <br>)
            const fullText = personnameElement.textContent || '';
            const lines = fullText.split('\n').map(line => line.trim()).filter(line => line);

            if (lines.length > 0) {
                // First line is usually the name
                const name = lines[0].trim();
                // Remove any trailing institutional info or email
                const cleanName = name
                    .replace(/\s*\(.*\).*$/, '') // Remove parenthetical content
                    .replace(/\s*,.*$/, '') // Remove comma and anything after
                    .trim();

                if (cleanName && !cleanName.includes('@')) {
                    authors.push(cleanName);
                }
            }
        }
    });

    return authors;
}

/**
 * Extract abstract from arXiv HTML
 * Pattern: <div class="ltx_abstract" id="abstract">
 */
function extractAbstract(doc: Document): string {
    const abstractElement = doc.querySelector('div.ltx_abstract#abstract');
    if (!abstractElement) return '';

    // Get all paragraphs in abstract
    const paragraphs = abstractElement.querySelectorAll('p.ltx_p');
    const abstractParts: string[] = [];

    paragraphs.forEach(p => {
        const text = p.textContent?.trim();
        if (text) {
            abstractParts.push(text);
        }
    });

    return abstractParts.join('\n\n');
}

/**
 * Extract main content sections, excluding References and other low-value sections
 */
function extractSections(doc: Document): ContentSection[] {
    const sections: ContentSection[] = [];

    // Get all top-level sections
    const sectionElements = doc.querySelectorAll('article.ltx_document > section.ltx_section');

    sectionElements.forEach(sectionElement => {
        const id = sectionElement.getAttribute('id') || '';

        // Skip References section
        if (id === 'bib' || sectionElement.classList.contains('ltx_bibliography')) {
            return;
        }

        // Skip Acknowledgments if present (usually has id like "acknowledgments" or in title)
        const titleElement = sectionElement.querySelector(':scope > h2.ltx_title');
        const title = titleElement?.textContent?.trim() || '';
        if (title.toLowerCase().includes('acknowledgment')) {
            return;
        }

        // Extract section data
        const section = extractSection(sectionElement);
        if (section) {
            sections.push(section);
        }
    });

    return sections;
}

/**
 * Extract a single section and its subsections recursively
 * Returns ContentSection directly
 */
function extractSection(sectionElement: Element): ContentSection | null {
    const id = sectionElement.getAttribute('id') || '';

    // Get section title - can be h2 (section), h3 (subsection), or h4 (subsubsection)
    const titleElement = sectionElement.querySelector(':scope > h2.ltx_title, :scope > h3.ltx_title, :scope > h4.ltx_title');
    if (!titleElement) return null;

    const fullTitle = titleElement.textContent?.trim() || '';

    // Extract section number and title
    // Pattern: "<span class="ltx_tag">1 </span>Introduction" or just "Introduction"
    const tagElement = titleElement.querySelector('span.ltx_tag');
    const number = tagElement?.textContent?.trim() || '';
    const title = fullTitle.replace(/^[\d\.\s]+/, '').trim();

    // Calculate level from number (e.g., "1" = level 1, "2.1" = level 2)
    const level = number ? number.split('.').filter(Boolean).length : 1;

    // Get direct content (paragraphs, not subsections)
    const contentParts: string[] = [];
    const directChildren = sectionElement.querySelectorAll(':scope > div.ltx_para, :scope > div.ltx_theorem, :scope > div.ltx_proof');

    directChildren.forEach(child => {
        const paragraphs = child.querySelectorAll('p.ltx_p');
        paragraphs.forEach(p => {
            const text = cleanText(p.textContent || '');
            if (text) {
                contentParts.push(text);
            }
        });
    });

    // Extract subsections recursively - including both ltx_section, ltx_subsection, and ltx_subsubsection
    const subsections: ContentSection[] = [];
    const subsectionElements = sectionElement.querySelectorAll(':scope > section.ltx_section, :scope > section.ltx_subsection, :scope > section.ltx_subsubsection');

    subsectionElements.forEach(subsectionElement => {
        const subsection = extractSection(subsectionElement);
        if (subsection) {
            subsections.push(subsection);
        }
    });

    return {
        level,
        title,
        content: contentParts.join('\n\n'),
        number: number || undefined,
        id: id || undefined,
        subsections: subsections.length > 0 ? subsections : undefined
    };
}

/**
 * Extract metadata from arXiv HTML
 */
function extractMetadata(doc: Document): {
    arxivId?: string;
    license?: string;
    publishDate?: string;
    version?: string;
    subjects?: string[];
} {
    const metadata: {
        arxivId?: string;
        license?: string;
        publishDate?: string;
        version?: string;
        subjects?: string[];
    } = {};

    // Extract arXiv ID, subjects, and date from watermark
    // Pattern: "arXiv:2510.20345v1 [cs.AI] 23 Oct 2025"
    const watermark = doc.querySelector('#watermark-tr');
    if (watermark) {
        const watermarkText = watermark.textContent || '';
        const match = watermarkText.match(/arXiv:([\d\.]+v?\d*)\s*\[(.*?)\]\s*(\d+\s+\w+\s+\d+)/);
        if (match) {
            metadata.arxivId = match[1];
            metadata.subjects = match[2].split(',').map(s => s.trim());
            metadata.publishDate = match[3];

            // Extract version number
            const versionMatch = match[1].match(/v(\d+)$/);
            if (versionMatch) {
                metadata.version = versionMatch[1];
            }
        }
    }

    // Extract license
    const license = doc.querySelector('#license-tr');
    if (license) {
        metadata.license = license.textContent?.trim();
    }

    return metadata;
}

/**
 * Extract references from the bibliography section
 * Pattern: <section class="ltx_bibliography" id="bib">
 *          <li class="ltx_bibitem" id="bib.bib46">
 */
function extractReferences(doc: Document): Reference[] {
    const references: Reference[] = [];

    // Find the bibliography section
    const bibSection = doc.querySelector('section.ltx_bibliography#bib');
    if (!bibSection) {
        console.log('No bibliography section found');
        return references;
    }

    // Get all bibliography items
    const bibItems = bibSection.querySelectorAll('li.ltx_bibitem');

    bibItems.forEach(item => {
        const id = item.getAttribute('id') || '';

        // Extract label/reference number (e.g., "Zhao et al. (2024)")
        const labelElement = item.querySelector('.ltx_tag_bibitem');
        const label = labelElement?.textContent?.trim() || '';

        // Get full citation text
        const citationText = item.textContent?.trim() || '';

        // Try to parse components from the citation text
        // This is basic parsing - could be enhanced with more sophisticated logic
        const bibBlocks = item.querySelectorAll('.ltx_bibblock');
        let authors: string[] | undefined;
        let title: string | undefined;
        let venue: string | undefined;
        let year: string | undefined;
        let doi: string | undefined;
        let url: string | undefined;

        bibBlocks.forEach((block, index) => {
            const text = block.textContent?.trim() || '';

            if (index === 0) {
                // First block usually contains authors
                const authorText = text.replace(/\.$/, '').trim();
                if (authorText && !authorText.toLowerCase().includes('doi:') && !authorText.toLowerCase().includes('url:')) {
                    authors = authorText.split(/,\s*and\s+|,\s+|\s+and\s+/).map(a => a.trim());
                }
            } else if (index === 1 && !text.toLowerCase().includes('doi:')) {
                // Second block often contains title
                title = text.replace(/\.$/, '').trim();
            } else if (text.match(/\d{4}/)) {
                // Block with year
                const yearMatch = text.match(/\b(19|20)\d{2}\b/);
                if (yearMatch) {
                    year = yearMatch[0];
                }
                // This block might also contain venue
                if (!venue) {
                    venue = text.replace(/\.$/, '').trim();
                }
            }

            // Check for DOI
            if (text.toLowerCase().includes('doi:')) {
                const doiMatch = text.match(/doi:\s*([^\s,]+)/i);
                if (doiMatch) {
                    doi = doiMatch[1];
                }
            }
        });

        // Check for URLs
        const linkElement = item.querySelector('a.ltx_url');
        if (linkElement) {
            url = (linkElement as HTMLAnchorElement).href;
        }

        references.push({
            id,
            label,
            citationText,
            authors,
            title,
            venue,
            year,
            doi,
            url,
        });
    });

    console.log(`Extracted ${references.length} references`);
    return references;
}

/**
 * Extract figures and their captions
 * Pattern: <figure class="ltx_figure" id="S1.F1">
 */
function extractFigures(doc: Document): Figure[] {
    const figures: Figure[] = [];

    const figureElements = doc.querySelectorAll('figure.ltx_figure');

    figureElements.forEach(fig => {
        const id = fig.getAttribute('id') || '';

        // Extract caption
        const captionElement = fig.querySelector('figcaption');
        let caption = '';
        let number = '';

        if (captionElement) {
            caption = captionElement.textContent?.trim() || '';

            // Try to extract figure number from caption
            // Pattern: "Figure 1: " or "Fig. 2.1: "
            const numberMatch = caption.match(/^(?:Figure|Fig\.?)\s+([\d\.]+):/i);
            if (numberMatch) {
                number = numberMatch[1];
            }
        }

        // Extract image URL
        const imgElement = fig.querySelector('img');
        const imageUrl = imgElement?.getAttribute('src') || undefined;

        if (caption || imageUrl) {
            figures.push({
                id,
                caption,
                imageUrl,
                number,
            });
        }
    });

    console.log(`Extracted ${figures.length} figures`);
    return figures;
}

/**
 * Clean text by removing excessive whitespace and button artifacts
 */
function cleanText(text: string): string {
    return text
        .replace(/Report issue for preceding element/g, '') // Remove button text
        .replace(/\s+/g, ' ') // Normalize whitespace
        .trim();
}

/**
 * Check if a document is an arXiv HTML paper
 */
function isArxivHtml(doc: Document): boolean {
    const hasArxivStructure =
        doc.querySelector('div.ltx_abstract#abstract') !== null ||
        doc.querySelector('section.ltx_bibliography#bib') !== null ||
        doc.querySelector('#watermark-tr') !== null;

    return hasArxivStructure;
}
