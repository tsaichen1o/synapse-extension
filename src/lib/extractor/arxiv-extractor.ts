/**
 * ArxivExtractor - Specialized extractor for arXiv HTML papers
 * 
 * ArXiv HTML has a very well-organized structure generated by LaTeXML:
 * - Authors: <span class="ltx_creator ltx_role_author">
 * - Sections: <section class="ltx_section" id="S1">, <section class="ltx_section" id="S2">, etc.
 * - Abstract: <div class="ltx_abstract" id="abstract">
 * - Title: <h1 class="ltx_title ltx_title_document">
 * 
 * This extractor:
 * 1. Extracts arXiv-specific structured data
 * 2. Converts directly to standardized PageContent format for AI Services
 * 3. Preserves hierarchical section structure using ContentSection
 */

import { PageContent, ContentSection } from '../types';

/**
 * Extract arXiv paper and convert to standardized PageContent
 * This is the main entry point for the arXiv extractor
 */
export function extractArxivPaper(doc: Document): PageContent | null {
    if (!isArxivHtml(doc)) {
        return null;
    }

    const title = extractTitle(doc);
    const authors = extractAuthors(doc);
    const abstract = extractAbstract(doc);
    const sections = extractSections(doc);
    const arxivMetadata = extractMetadata(doc);

    // Generate markdown content from sections
    const mainContent = sectionsToMarkdown(sections);

    // Extract tags from section titles
    const tags = extractTags(sections);

    return {
        title,
        url: window.location.href,
        fullText: abstract + '\n\n' + mainContent,

        metadata: {
            authors,
            contentType: 'research-paper',
            tags,
            description: abstract,
            sections,
            publishDate: arxivMetadata.publishDate,
            extra: {
                arxivId: arxivMetadata.arxivId,
                license: arxivMetadata.license,
                arxivVersion: arxivMetadata.version,
                subjects: arxivMetadata.subjects,
            }
        },

        images: [],
        links: [],
    };
}

/**
 * Convert sections to markdown format
 */
function sectionsToMarkdown(sections: ContentSection[]): string {
    const parts: string[] = [];

    sections.forEach(section => {
        parts.push(...sectionToMarkdown(section, 2)); // Start at h2 (h1 is for title)
    });

    return parts.join('\n');
}

/**
 * Convert a single section to markdown
 */
function sectionToMarkdown(section: ContentSection, baseLevel: number): string[] {
    const parts: string[] = [];
    const prefix = '#'.repeat(baseLevel);

    // Section heading
    const heading = section.number
        ? `${prefix} ${section.number} ${section.title}`
        : `${prefix} ${section.title}`;
    parts.push(heading);

    // Section content
    if (section.content) {
        parts.push(section.content);
        parts.push('');
    }

    // Subsections
    section.subsections?.forEach(subsection => {
        parts.push(...sectionToMarkdown(subsection, baseLevel + 1));
    });

    return parts;
}

/**
 * Extract tags from section titles
 */
function extractTags(sections: ContentSection[]): string[] {
    const tags: string[] = [];

    sections.forEach(section => {
        // Skip generic sections
        if (!['Introduction', 'Conclusion', 'References'].includes(section.title)) {
            tags.push(section.title);
        }
    });

    return tags
}

/**
 * Extract title from arXiv HTML
 */
function extractTitle(doc: Document): string {
    const titleElement = doc.querySelector('h1.ltx_title.ltx_title_document');
    return titleElement?.textContent?.trim() || 'Untitled';
}

/**
 * Extract authors from arXiv HTML
 * Pattern: <span class="ltx_creator ltx_role_author">
 */
function extractAuthors(doc: Document): string[] {
    const authors: string[] = [];
    const authorElements = doc.querySelectorAll('span.ltx_creator.ltx_role_author');

    authorElements.forEach(element => {
        // Get the personname element
        const personnameElement = element.querySelector('span.ltx_personname');
        if (personnameElement) {
            // Extract just the name (first line before <br>)
            const fullText = personnameElement.textContent || '';
            const lines = fullText.split('\n').map(line => line.trim()).filter(line => line);

            if (lines.length > 0) {
                // First line is usually the name
                const name = lines[0].trim();
                // Remove any trailing institutional info or email
                const cleanName = name
                    .replace(/\s*\(.*\).*$/, '') // Remove parenthetical content
                    .replace(/\s*,.*$/, '') // Remove comma and anything after
                    .trim();

                if (cleanName && !cleanName.includes('@')) {
                    authors.push(cleanName);
                }
            }
        }
    });

    return authors;
}

/**
 * Extract abstract from arXiv HTML
 * Pattern: <div class="ltx_abstract" id="abstract">
 */
function extractAbstract(doc: Document): string {
    const abstractElement = doc.querySelector('div.ltx_abstract#abstract');
    if (!abstractElement) return '';

    // Get all paragraphs in abstract
    const paragraphs = abstractElement.querySelectorAll('p.ltx_p');
    const abstractParts: string[] = [];

    paragraphs.forEach(p => {
        const text = p.textContent?.trim();
        if (text) {
            abstractParts.push(text);
        }
    });

    return abstractParts.join('\n\n');
}

/**
 * Extract main content sections, excluding References and other low-value sections
 */
function extractSections(doc: Document): ContentSection[] {
    const sections: ContentSection[] = [];

    // Get all top-level sections
    const sectionElements = doc.querySelectorAll('article.ltx_document > section.ltx_section');

    sectionElements.forEach(sectionElement => {
        const id = sectionElement.getAttribute('id') || '';

        // Skip References section
        if (id === 'bib' || sectionElement.classList.contains('ltx_bibliography')) {
            return;
        }

        // Skip Acknowledgments if present (usually has id like "acknowledgments" or in title)
        const titleElement = sectionElement.querySelector(':scope > h2.ltx_title');
        const title = titleElement?.textContent?.trim() || '';
        if (title.toLowerCase().includes('acknowledgment')) {
            return;
        }

        // Extract section data
        const section = extractSection(sectionElement);
        if (section) {
            sections.push(section);
        }
    });

    return sections;
}

/**
 * Extract a single section and its subsections recursively
 * Returns ContentSection directly
 */
function extractSection(sectionElement: Element): ContentSection | null {
    const id = sectionElement.getAttribute('id') || '';

    // Get section title - can be h2 (section), h3 (subsection), or h4 (subsubsection)
    const titleElement = sectionElement.querySelector(':scope > h2.ltx_title, :scope > h3.ltx_title, :scope > h4.ltx_title');
    if (!titleElement) return null;

    const fullTitle = titleElement.textContent?.trim() || '';

    // Extract section number and title
    // Pattern: "<span class="ltx_tag">1 </span>Introduction" or just "Introduction"
    const tagElement = titleElement.querySelector('span.ltx_tag');
    const number = tagElement?.textContent?.trim() || '';
    const title = fullTitle.replace(/^[\d\.\s]+/, '').trim();

    // Calculate level from number (e.g., "1" = level 1, "2.1" = level 2)
    const level = number ? number.split('.').filter(Boolean).length : 1;

    // Get direct content (paragraphs, not subsections)
    const contentParts: string[] = [];
    const directChildren = sectionElement.querySelectorAll(':scope > div.ltx_para, :scope > div.ltx_theorem, :scope > div.ltx_proof');

    directChildren.forEach(child => {
        const paragraphs = child.querySelectorAll('p.ltx_p');
        paragraphs.forEach(p => {
            const text = cleanText(p.textContent || '');
            if (text) {
                contentParts.push(text);
            }
        });
    });

    // Extract subsections recursively - including both ltx_section, ltx_subsection, and ltx_subsubsection
    const subsections: ContentSection[] = [];
    const subsectionElements = sectionElement.querySelectorAll(':scope > section.ltx_section, :scope > section.ltx_subsection, :scope > section.ltx_subsubsection');

    subsectionElements.forEach(subsectionElement => {
        const subsection = extractSection(subsectionElement);
        if (subsection) {
            subsections.push(subsection);
        }
    });

    return {
        level,
        title,
        content: contentParts.join('\n\n'),
        number: number || undefined,
        id: id || undefined,
        subsections: subsections.length > 0 ? subsections : undefined
    };
}

/**
 * Extract metadata from arXiv HTML
 */
function extractMetadata(doc: Document): {
    arxivId?: string;
    license?: string;
    publishDate?: string;
    version?: string;
    subjects?: string[];
} {
    const metadata: {
        arxivId?: string;
        license?: string;
        publishDate?: string;
        version?: string;
        subjects?: string[];
    } = {};

    // Extract arXiv ID, subjects, and date from watermark
    // Pattern: "arXiv:2510.20345v1 [cs.AI] 23 Oct 2025"
    const watermark = doc.querySelector('#watermark-tr');
    if (watermark) {
        const watermarkText = watermark.textContent || '';
        const match = watermarkText.match(/arXiv:([\d\.]+v?\d*)\s*\[(.*?)\]\s*(\d+\s+\w+\s+\d+)/);
        if (match) {
            metadata.arxivId = match[1];
            metadata.subjects = match[2].split(',').map(s => s.trim());
            metadata.publishDate = match[3];

            // Extract version number
            const versionMatch = match[1].match(/v(\d+)$/);
            if (versionMatch) {
                metadata.version = versionMatch[1];
            }
        }
    }

    // Extract license
    const license = doc.querySelector('#license-tr');
    if (license) {
        metadata.license = license.textContent?.trim();
    }

    return metadata;
}

/**
 * Clean text by removing excessive whitespace and button artifacts
 */
function cleanText(text: string): string {
    return text
        .replace(/Report issue for preceding element/g, '') // Remove button text
        .replace(/\s+/g, ' ') // Normalize whitespace
        .trim();
}

/**
 * Check if a document is an arXiv HTML paper
 */
function isArxivHtml(doc: Document): boolean {
    const hasArxivStructure =
        doc.querySelector('div.ltx_abstract#abstract') !== null ||
        doc.querySelector('section.ltx_bibliography#bib') !== null ||
        doc.querySelector('#watermark-tr') !== null;

    return hasArxivStructure;
}
